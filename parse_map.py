import re
from ida_kernwin import Form
from idc import set_name, get_cmt, set_cmt, SN_NOWARN
from idaapi import add_segm

# Script to parse a .map file generated by armlink, based on an input scatter file. Appropriate 
# segments are created and symbols are added to the database.

class FileDialog(Form):
    def __init__(self):
        self.invert = False
        Form.__init__(self, r"""STARTITEM 0
BUTTON YES* Open
BUTTON CANCEL Cancel
Open map file

<#Select a file to open#Map file path:{iFileOpen}>
""", { 'iFileOpen': Form.FileInput(open=True) })

def show_file_dialog():
    f = FileDialog()
    f.Compile()
    f.iFileOpen.value = "*.*"
    ok = f.Execute()
    file_path = None
    if ok == 1:
        file_path = f.iFileOpen.value
        print(f"Selected file: {file_path}")
    else:
        print("No file selected.")
    f.Free()
    return file_path

def parse_symbol_table(lines):
    symbols = []
    in_table = False
    for line in lines:
        if "Symbol Name" in line and "Object(Section)" in line:
            in_table = True
            continue
        if in_table:
            if line.strip() == "" or line.startswith("="):
                continue
            # Section symbols are filtered out implicitly
            m = re.match(r"^([\w.]+)\s+(0x[0-9a-fA-F]+)\s+(\w+\x20?\w*)\s+(\d+)\s+(\S+)", line.strip())
            if m:
                # skip source files
                if int(m.group(2), 16) == 0:
                    continue
                symbols.append({
                    "name": m.group(1),
                    "address": int(m.group(2), 16),
                    "type": m.group(3).strip(),
                    "size": int(m.group(4)),
                    "object": m.group(5)
                })
    return symbols

def parse_memory_map(lines):
    regions = []
    region = None
    exec_region = None
    for line in lines:
        # Detect Load Region
        m = re.match(r"\s*Load Region (\S+) \(Base: (0x[0-9a-fA-F]+), Size: (0x[0-9a-fA-F]+),.*\)", line)
        if m:
            region = {
                "name": m.group(1),
                "base": int(m.group(2), 16),
                "size": int(m.group(3), 16),
                "exec_regions": []
            }
            regions.append(region)
            continue
        # Detect Execution Region
        m = re.match(r"\s*Execution Region (\S+) \(Base: (0x[0-9a-fA-F]+), Size: (0x[0-9a-fA-F]+),.*\)", line)
        if m:
            exec_region = {
                "name": m.group(1),
                "base": int(m.group(2), 16),
                "size": int(m.group(3), 16),
                "sections": []
            }
            if region:
                region["exec_regions"].append(exec_region)
            continue
        # Detect section entries
        m = re.match(r"\s*(0x[0-9a-fA-F]+)\s+(0x[0-9a-fA-F]+)\s+(\w+)\s+(\w+)\s+(\d+)\s+(\S+)\s+(\S+)", line)
        if m and exec_region:
            exec_region["sections"].append({
                "base": int(m.group(1), 16),
                "size": int(m.group(2), 16),
                "type": m.group(3),
                "attr": m.group(4),
                "idx": int(m.group(5)),
                "section_name": m.group(6),
                "object": m.group(7)
            })
    regions.sort(key=lambda x: x['base'])
    return regions

def create_segments(regions):
    region_map = []

    for region in regions:
        region_size = 0
        # If the region size is zero, we need to calculate it from execution regions
        if region["size"] == 0 and "_end" not in region['name'].lower():
            region_size = sum([exec_region['size'] for exec_region in region["exec_regions"]])
            # If still zero, extend it to the next region's base
            if region_size == 0 and regions.index(region) < len(regions) - 1:
                next_region = regions[regions.index(region) + 1]
                region_size = next_region['base'] - region['base']
        # If the region is an end region, we extend the last region's size
        elif region["size"] == 0 and "_end" in region['name'].lower():
            prev_region = region_map[-1]
            prev_region['size'] = region['base'] - prev_region['base']
        else:
            region_size = region["size"]

        region_map.append({
            "name": region['name'],
            "base": region['base'],
            "size": region_size,
            "exec_regions": region["exec_regions"]
        })

    for region in region_map:
        print(f"Creating segment for {region['name']} at base {hex(region['base'])} with size {hex(region['size'])}")
        add_segm(0, region['base'], region['base'] + region['size'], region['name'], "CODE")
        
        for exec_region in region["exec_regions"]:
            print(f"  Execution Region: {exec_region['name']} at base {hex(exec_region['base'])} with size {hex(exec_region['size'])}")
            set_name(exec_region['base'], exec_region['name'], SN_NOWARN)
            cmt = get_cmt(exec_region['base'], 0)
            if cmt is None:
                cmt = ""
            cmt += exec_region['name'] + "; "
            set_cmt(exec_region['base'], cmt, 0)

def label_symbols(symbols):
    for sym in symbols:
        # Clear Thumb bit
        if sym['type'] == "Thumb Code":
            sym['address'] &= ~1
        # Can override less descriptive names from the memory map regions
        set_name(sym['address'], sym['name'], SN_NOWARN)
        cmt = get_cmt(sym['address'], 1)
        if cmt is None:
            cmt = ""
        cmt += sym['name'] + "; "
        set_cmt(sym['address'], cmt, 1)

def main():
    file_path = show_file_dialog()
    if not file_path:
        return

    with open(file_path, "r") as f:
        lines = f.readlines()

    # Parse symbol table
    symbols = parse_symbol_table(lines)

    # Parse memory map
    regions = parse_memory_map(lines)

    # Create segments based on memory regions
    create_segments(regions)
    
    # Now label all symbols
    label_symbols(symbols)

    print("Remember to fix the segment permissions!")

if __name__ == "__main__":
    main()
